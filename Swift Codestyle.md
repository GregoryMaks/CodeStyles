# Swift Codestyle

> [TOC]

## Tabs and indentation

* Use spaces instead of tabs (by default Xcode converts tabs to spaces). Tab = 4 spaces;
* It is agreed to have 140 character limit for one line. Please set XCode delimiter in settings accordingly;
* End files with a newline.

## Comments

Remove autogenerated code and unused methods and variables.
Avoid self explanatory comments - code should be self-documenting.

It is usually a good practice to briefly document class and methods with intergrated documenting feature in XCode, but for now it is optional and can be discussed in place.

## Semicolons

Do not use semicolons at end of the line.

## Curly braces

Curly braces should be put on the same line as enclosing declaration, for example:

```swift
if let foo != nil {
   ...
} else {
   ...
}
```

For constructions which can contain multiple blocks (like if-else, do-catch-finally) it is required to put 2nd and following keyword on the same line as the closing brace, for example:

```swift
if price > 200.0 {
   ...
} else if price < 50.0 {
   ...
}

do {
	makeSomeWork()
} catch {
	relax()
} finally {
	grabSomeFood()
}
```


They can also be moved to the next line if it makes code easier to read - mostly for long lines. Also they must be put on the next line when function name, guard clause or if condition consists of multiple lines.
For example:

```swift
func extremelyAwesomeMethodWithMupltipleParameters(parameterOne: String,
                                                   andClosure closure: String -> Void)
{
    guard let object = object 
        where object.isValid else
    {
        ...
    }
}
```

In one case, if we write a simple and short statement realated with **if**/**guard** operator, it is advised (even required in most cases) to write it in one line without brace transferring.
This will increase readability and reduce code size.
For example:

```swift
func append(data: Data?) {
    guard let data = data else { return }
    ...
}
```

## Naming

Class, protocol and category names must consist of words and generally accepted abbreviations (Facebook - FB, etc.), each of which begins with a capital letter. Examples:

```swift
class ContactTableViewCell: UITableViewCell
class RefreshableDataSource
protocol AuthorizationDelegate
```

#### IBActions
Use action prefix for IBActions, such as 'tap', 'swipe' etc.
```swift
func tapCloseButton(sender: UIButton) {
    ...
}
```

#### Constants naming
Constant naming is deprecated due to new code styling rules, see [Constants](#constants) section.

### Protocols

When picking a protocol name, always consider what your protocol is about. If it declares that type can be something else, use `Convertible` word in a name, for example:

```swift
protocol JSONConvertible
protocol APIFilterable
```

If your protocol defines an action or capability, that can be performed on or by instance of your object, use -able or -ible suffix:

```swift
protocol Streamable
protocol Mappable
protocol MemberContentVisible
```

If your protocol serves as a data source or a delegate, you can end name of your protocol with `DataSource` or `Delegate` ending.

If we accept PDD (Protocol driven development) concept we can name base protocols for classes by appending `Protocol` word as suffix to it, for example

```swift
protocol NetworkServiceProtocol {}

class NetworkService: NetworkServiceProtocol {}
```

### Variables

Variable names should begin with lower case letter. Use descriptive names to clarify your intent:

```swift
// Good
let maximumPreviewCount = 5

// Bad
let MAX_PR_COUNT = 5
```

Acronyms like URL or ID should never be mixed case, and whether they are upper or lower case depends on the position in the identifier:

Wrong:
```swift
var ID: String
var imageUrl: URL
typealias Id = String
typealias UniqueId = String
```

Right:
```swift
var id: String
var imageURL: URL
typealias ID = String
typealias UniqueID = String
```

### Properties

Do not use computed properties for any complex logic. Anything longer than 2-3 lines should go elsewhere.
Remember, setter/getter side effects are very hard to debug, e.g. :
```swift
var width = 100.0
var height = 100.0

var area: Double {
    get {
        return width * height
    }
    set(newArea) {
        let squareRootValue = sqrt(newArea)
        width = squareRootValue
        height = squareRootValue
    }
}
```
This is extremely bad idea, client code changing area is not aware of other properties changes triggered by `area` setter.

### Methods

#### Swift-style
For functions and methods, prefer named parameters unless intent and context are completely clear. Follow Apple convention to always name first argument in the name of the method:

```swift
class Counter {
    func combineWith(otherCounter: Counter) { ... }
    func incrementBy(amount: Int) { ... }
}
```

You can omit first parameter name (completely or partially) if it can be inferred from parameter type, for instance:
```swift
class SomeCollection {
    func remove(_ item: Item)
}

class DataSource {
    func item(at indexPath: NSIndexPath) { ... }
}
```

For methods that contain special parameter prefix as `for`, `as`, `at`, etc. this prefix should be included into first parameter name, for example:

```swift
func item(at index: Int) -> Item
func string(for person: Person) -> String
```

If the number of arguments is more than one and prefix is related to all of them, it should be included in method name:

```swift
func stringFor(country: String, city: String, state: String?) -> String
```

#### Multiline

If the method declaration (including return parameter doesn't fit into line length limitation (see specific number below) one should apply the following rule to make it multiline:

Bad:
```swift
func moduleConfigured(for viewController: PatientListViewController, 
				      moduleOutput: PatientListModuleOutput) -> PatientListModuleInput
```
Good:
```swift
func moduleConfigured(
	for viewController: PatientListViewController, 
	moduleOutput: PatientListModuleOutput
) -> PatientListModuleInput
```

Exception can be made for class `init` method, for example: 

Bad:
```swift
init(
	for viewController: PatientListViewController, 
	moduleOutput: PatientListModuleOutput
) -> PatientListModuleInput
```

Good:
```swift
func init(for viewController: PatientListViewController, 
          moduleOutput: PatientListModuleOutput) -> PatientListModuleInput
```

### Delegates

Delegate method naming should conform to Apple guidelines.

In case of method that provide reference to root object (e.g. `tableView` for `UITableViewDelegate`) the method declaration should look like this:
```swift
func view(_ view: View, didChangeFieldValueTo value: String)
```

If the sender (`view` above) is not included, the method declaration looks like this:
```swift
func field(_ field: Field, didChangeTextTo text: String)
OR
func fieldDidChangeTextTo(_ text: String)
```

For simple action delegate methods that do not accept any parameter the naming should include action and then subject, for example:
```swift
func didTapForgotPassword()
```

### Tuples

Give tuple variables names, when this is appropriate. Leave unnamed tuple only when intent is very clear.

```swift
// Not preferred
let foo = (1, "user")

// Preferred
let foo = (userId: 1, userName: "user")
```

### Typealiases & Associated types

Typealiases should be short and meaningful. For example:

```swift
typealias MoneyAmount = Double

associatedtype ModelType
```

### Generic types

Generic types should start with letter `T`, then `U`, `V` and so on. You can use different names to make usage of generics more clear, for example:

```swift
public struct CollectionViewSection<Item>: CollectionViewSectionInfo {}
```

## Immutability

Always prefer `let` declarations over `var`. It clearly sends a message that value will not be changed. 

Prefer value types over reference types. Use structs instead of classes when you don't need reference semantics. Using value types provides a lot of benefits, such as protection against changing from different owners. It also frees you from memory management, because value types are copied instead of passing by reference. And it also provides thread-safety for your objects.

If your classes don't need any inheritance, mark them `final` to let compiler know, that class will not be subclassed.

```swift
final class User {}
```

This provides perfomance improvements in code compilation and in runtime (see [Apple Swift Blog](https://developer.apple.com/swift/blog/?id=27)).

## Access Control

Declare properties and methods `private`, when they should not be visible from outside of current file. Keep in mind, that private properties and methods are actually marked as `final` by compiler, optimizing perfomance. Don't add modifiers, if they are already a default. For example:

```swift
// Not preferred
internal extension String {
    var uppercaseString: String
}

// Preferred
extension String {
    var uppercaseString: String
}
```

#### Outlets

Declare outlets as `private`.

## Closures

Use trailing closures, when intent is clear, and last parameter name is not relevant, for example:

```swift
// Not preferred
UIView.animateWithDuration(0.5, animations: {
    view.alpha = 1
})

// Preferred
UIView.animateWithDuration(0.5) {
    view.alpha = 1
}

```

Minimize parameter names that go inside closures to simplify closure syntax, for example:

```swift
// Not preferred
request.perform(success: { (responseObject, response) -> Void in
    // Do something
})

// Preferred
request.perform(success: { responseObject, _ in
    // Do something
})
```

#### [weak self] / [unowned self]

Do not bluntly use `weak self` in every closure - figure out, where it is really needed  - most of the time it happens when closure is stored on your object. In previous examples with UIView animation it is not needed. And even if you do have retain cycles, if your object existance is guaranteed, use `[unowned self]` instead of weak to minimize optionals. Remember, that self is not the only one object, that can be part of retain cycles. If you have multiple arguments in capture list, remember to put weak or unowned before each one, for example:

```swift
let foo = Foo()
foo.performStuff { [weak self, unowned foo] in
    self.method()
    foo.method()
}
```

#### Strongify weak self

When weak self is used in closure it may me useful to strongify it inside to reduce usage of optional self variable.
Use variable with name `self` to hide optional self and make its usage consistent across all code (inside and outside of closures), like this:
```swift
foo.performStuff { [weak self] in
    guard let `self` = self else { return }
    self.method()
}
```

#### Closure parameters

You can omit parameter names in closures, if it's absolutely clear, what closure parameter is.

Also if your line is short, you can have curly braces on the same line.

```swift
let artworkDictionaryArray: [[String: AnyObject]] = ...

// Not preferred
let parsedArtworksArray = artworkDictionaryArray.map({ dictionary in
    return Artwork(dictionary: dictionary)
})

// Preferred
let parsedArtworksArray = artworkDictionaryArray.map { Artwork(dictionary: $0) }
```


## Objective-C runtime

Don't include objective-c runtime unless absolutely necessary. For example, Swift protocols do not allow optional methods. Instead of declaring protocol @objc, try to split protocols into several ones. Treat your protocols like traits, that may or may not be present. For example:

```swift
// Not Preferred
@objc protocol MovementAbilities {
    optional var speed: CGFloat { get }
    optional var maximumDepth: CGFloat { get }
}

class User: MovementAbilities {}

// Preferred
protocol Runner {
    var speed: CGFloat { get }
}

protocol Swimmer {
    var maximumDepth: CGFloat { get }
}

class User: Runner, Swimmer {}
```

Try to work with compile-time representations of data types instead of runtime. Avoid using `dynamic` attributes (unless it's CoreData, where it's required).

Use Swift native types instead of Objective-C ones whenever possible. For example, use `String` instead of `NSString`, and `Int` instead of `NSNumber`.

Use `@objс private` for private actions and handlers (timers, notifications etc.)

## Explicit references to `self`

Only use explicit `self` when compiler requires you to, for example in constructors or in closures.

```swift
// Constructors
struct Person {
    let firstName: String
    let lastName: String

    init(firstName: String, lastName: String) {
        self.firstName = firstName
        self.lastName = lastName
    }
}

// Closures
foo.performStuff {
    self.method()
}
```



## Optionals

Avoid using force unwrapping. Use optional chaining or `if let` bindings to unwrap optional values.

```swift
var name: String?
var age: String?

if let name = name, age = age where age >= 13 {
    // ...
}

foo?.callSomethingIfFooIsNotNil()
```

Use nil-coalescing operator to avoid using force-unwrapping or checking for nil, for example:

```swift
if user?.isValid ?? false {
    // .. Do something
}

let baseURL = NSURL(string: "https://myserver.com/") ?? NSURL()
```

Prefer guard construct to break/return early.

```swift
func makePaymentForUser(user: User) {
    guard let creditCard = user.creditCard else { return }

    creditCard.withdrawAmount(500000)
}
```

You can also use `map` or `flatMap` on `Swift.Optional` enum to create clean and readable code. But do not overuse then so the code becomes unreadable.

```swift
func performOperation(on object: Object?) {
    object.map { $0.perform() }
}
```

#### Force unwrapping

There are several cases, where usage of force unwrapping is allowed. 

Mostly it is allowed in cases where application can no longer run if the variable is nil. But it it still highly unadvisable to use force unwrapping in most cases.

For example, IBOutlets are guaranteed to exist, and you need to crash application if they don't, so this is allowed:

```swift
class ProfileViewController: UIViewController {
    @IBOutlet weak var firstNameTextField: UITextField!
}
```

Another use case is unit tests, if you have your "system under test" created in setup method:

```swift
class UserTestCase: XCTestCase {
    var user: User!

    func setUp() {
        super.setUp()
        user = User.fixture()
    }

    func testUser() {
        XCTAssert(user.isValid())
    }
}
```

## Implicit getters

Read-only computed properties don't need explicit getter:

```swift
// Not Preferred
var quality: CGFloat {
    get {
        return 5.0
    }
}

// Preferred
var quality: CGFloat {
    return 5.0
}

```

## Omitting type parameters

Omit type parameters, when they can be inferred by compiler, for example:

```swift
// Not preferred:
var color: UIColor = UIColor.clearColor()
view.backgroundColor = UIColor.clearColor()

// Preferred:
var color = UIColor.clearColor()
view.backgroundColor = .clearColor()
```

## Syntactic sugar

Prefer shortcut versions of type declarations over full generics syntax:

```swift
// Not preferred
let models: Array<String>

// Preferred
let models: [String]
```

## Struct initializers

Use native Swift initializers rather then legacy CGGeometry constructors

```swift
// Not preferred
let bounds = CGRectMake(40, 20, 120, 80)
let centerPoint = CGPointMake(96, 42)

// Preferred
let bounds = CGRect(x: 40, y: 20, width: 120, height: 80)
let centerPoint = CGPoint(x: 96, y: 42)
```

Prefer struct-scope constants like `Int.max` to legacy ones like `CGRectZero`.

## Structuring code

When conforming to a protocol, create extension with conformance methods:

```swift
class MyViewController: UIViewController {
}

extension MyViewController: UIScrollViewDelegate {
    // Scroll View delegate methods
}
```

Add pragma marks to make particular code block clear. You can omit writing MARKs at all in tiny files (~< 50 lines).

#### Default MARKs and their order

- [Optional] Typealiases (typealiases)
- [Optional] Subtypes (classes, structs, enums, etc. contained inside class)
- Public Properties
- Private Properties
- Outlets
- Lifecycle (init, deinit methods)
- Overriden methods
- Public Methods
- UI Actions (IBActions, other UI actions)
- Notifications (NSNotification tribute)
- Private Methods

```swift
class MyViewController: UIViewController {

    // MARK: - Lifecycle

    override func viewDidLoad() {
        super.viewDidLoad()
        // ...
    }

    // MARK: - UI Actions

    @IBAction func buttonTapped() {
        // ...
    }
}
```

You can also separate parts of your class methods into groups using extensions placed in the same file as the original class.

Always add pragma mark before extension declaration as they cannot hold descriptive names in the declaration itself.

Do not misuse this approach, try to use it in exceptional cases to make your code easier to read and you logic clear.

```swift
class MyViewController: UIViewController {

    // MARK: - View lifecycle

    override func viewDidLoad() {
        super.viewDidLoad()
        // ...
    }

}

// MARK: - Session related

extension MyViewController {
    
    private func openSession() {
    }

    private func closeSession() {
    }

}
```

### Delimiters

Use **none or 1 line** delimiter between properties 

Use **1 line** delimiter between methods

Use **1 line** delimiter between different inner types (methods - properties, properties - types, etc.)

Use **2 lines** delimiter between top file objects like classes / protocols / structs / enums

In general, try to keep files simple. Every file, that has **more than 300 lines of code**, needs to have a valid reason to be like that. If your source file size is **more than 500 lines**, this should be considered a technical debt, have a lint warning and be split into several files.

## Extensions

When picking extension file name, consider functionality you are providing. For example, if you write extension on UIImage, that will provide placeholders, name it `UIImage+Placeholders`. If it is hard to determine, which functionality is added, using one word, name it with `+Extensions` suffix like so: `UIImage+Extensions`.

## Constants

### Global constants

Global constants should be put in one enum named `XXConstants` (where XX is your app prefix) and be located in the similarly named file.
Constants can be separated by putting them into inner structs.

For example:
```swift
// GlobalConstants.swift

enum GlobalConstants {

    static let defaultAnimationDuration: NSTimeInterval = 2.0

    struct Networking {
        static let aboutPreviewURL = "http://your-site.com/about"
    }

}
```
It is strongly advised to separate constants into different structures judging on their usage scope (networking, global notifications, visual styling, etc.).

### Class constants

Class constants should be put in an inner `enum` with a distinctive, short and meaningful name.
Enum is chosen for a reason, it cannot be instantiated without cases, thus is carefully protected.
For class-wide constants `struct Constants {}` should be used.
Also there can be many constants containers and their name may differ from `Constants`.

For example:
```swift
class SomeViewController {

    private enum Constants {
        static let animationCycleDuration: NSTimeInterval = 3.0
    }

    struct Notifications {
        static let outerNotificationName = "OuterNotificationName"
        private static let innerNotificationName = "InnerNotificationName"
    }

}
```

`Constants` can be made `private` depending on the needs, consequently inner members of the struct can be similarly made `private` to limit their usage from the outside.

## Other

Use expression #keyPath() to build a compile-time valid key-path string:
```swift
CDStudent.mr_findFirst(byAttribute: #keyPath(CDStudent.studentServerID), withValue: studentServerID, in: workingContext)
```

## References

* [Swift programming language book](https://developer.apple.com/library/ios/documentation/Swift/Conceptual/Swift_Programming_Language/)
* [Github Swift guidelines](https://github.com/github/swift-style-guide)
* [raywenderlich.com Swift guidelines](https://github.com/raywenderlich/swift-style-guide)
* [Swift API Design Guidelines](https://swift.org/documentation/api-design-guidelines/)

<!--stackedit_data:
eyJoaXN0b3J5IjpbLTY5OTkyNzAzNl19
-->